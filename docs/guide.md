# CPlusPlusThings Notes

## const

**const 和 #define 的区别**

- const 有类型，编辑器能进行安全检查
- #define是在预编译的时候简单的进行替换，

**extern与const**

- extern可以理解为申明但不定义，可以在别的源文件中定义，然后在当前源文件声明并使用。
- 由于const一般申明和定义同时进行，所以在其他源文件中要使用 `extern const int e = 12`, 然后在当前源文件中也要使用 `extern const int e`来申明。$S=\frac{a}{b} - \Delta$

!> important! $S=\frac{a}{b} - \Delta$ $S=\frac{a}{b} - \Delta$ $S=\frac{a}{b} - \Delta$

?> TODO list: ...
$$S=\frac{a}{b} - \Delta$$


$$S=\frac{a}{b} - \Delta$$

**指针与const**

- const位于*的左侧，则const用来修饰指针所指的对象，指针本身可以修改，指针所指对象不能修改

- const位于*的右侧，则const用来修饰指针，指针本身不能修改，指针所指的对象可以修改。

- 不能使用指向常量的指针修改所指对象，即时它指向了非const的对象，比较绕。

  ```cpp
  const int *ptr;
  int val = 3;
  ptr = &val //ok
  *ptr = 3 //error
  ```

- const指针必须进行初始化。

**函数与const**

- const在参数列表中，`const int var 和 int* const var `都无意义，前者按值传递，const就相当于修饰的拷贝，所以无意义。后者指针本身不可变，但是本身也是拷贝，所以无意义。
- 参数列表中， `const char *src` 是有意义的，可以保护该指针所指的变量在函数内部不被修改，这也是const的主要作用之一。
- 参数为引用 `const func(const A &a)`，可以增加效率的同时防止修改！

**类与const**

- 类中的const成员变量必须通过初始化列表进行初始化
- 类中的const成员函数只能访问const成员函数，非const成员函数可以访问所有成员函数
- 类中的const成员变量可以直接在类定义中用`static const int a=10` 或者 `const int apple=10` C++11是支持的

## static

**函数中的static变量**

- static变量只被初始化一次，在函数内部申明的static变量，在程序生命周期内绑定给该函数。时间上为全局变量，空间上为局部变量。

**类中的static变量**

- 类中的static变量由所有类实例共享，任何一个类的实例对类的static变量修改后都会修改所有实例，因为他们共享该static变量。
- 类中的静态变量应由用户使用类外的类名和范围解析运算符显式初始化，初始化的时候不加关键字static

**类的static实例**

- 类的static实例存在于整个程序生命周期，在main函数后调用析构函数。
- 非静态成员引用必须与特定对象相对，static函数只能调用static函数和static对象，因为调用类的static函数类似调用一个非类成员的自由函数。
- static还有限定访问范围的作用，可能是由于static是和代码文件绑定的。

## this

this作用域是在类内部，当在类的非静态成员函数中访问类的非静态成员的时候，编译器会自动将对象本身的地址作为一个隐含参数传递给函数。也就是说，即使你没有写上this指针，编译器在编译的时候也是加上this的，它作为非静态成员函数的隐含形参，对各成员的访问均通过this进行。

- 在类的非静态成员函数中返回类实例本身的时候，直接使用return *this
- this指针在非常函数中被解析成A* const this, 在常函数中被解析成const A* const this

## inline

**类中的inline**

- inline要想生效，要与函数的定义放在一起，是一种用于定义的关键字而不是声明。

**虚函数与inline**

- 虚函数通过指针调用呈现多态性时，需要在运行时才能确定，所以不能inline

## sizeof

- 空类的大小为1字节
- 类的大小需要与机器字长对其，例如64位机的类中有一个char 一个虚函数，则大小为1+8=16
- static成员，包括static变量与函数都影响类的大小，因为他们单独存储。所有成员函数都不占用类的空间。
- 对于包含虚函数的类，不管有多少个虚函数，只有一个虚指针vptr的大小。
- 派生类虚继承多个虚函数，会继承所有虚函数的vptr

```python
from matplotlib.colors import ListedColormap, LinearSegmentedColormap
top = cm.get_cmap('Reds_r', 127)
bottom = cm.get_cmap('Blues', 127)
newcolors = np.vstack((top(np.linspace(0, 1, 127)),bottom(np.linspace(0, 1, 127))))
newcmp_b = ListedColormap(newcolors, name='OrangeBlue')
```

## 函数指针

- `void (*pFun)(int);` 定义了一个指向函数的指针，该指针的输入为int 返回值为void
- `typedef void (*pFun)(int)` 新类型，而不是变量。

## 纯虚函数和抽象类

纯虚函数是指没有函数体的虚函数，直接在声明的时候赋值0，抽象类是指包含纯虚函数的类

- 抽象类中，成员函数可以调用纯虚函数，构造和析构中不能使用纯虚函数
- 如何一个类从抽象类中派生，则它必须实现基类中所有的纯虚函数，才能成为非抽象类。

## 虚函数表

![虚函数表](https://github.com/PerhapsChen/CPlusPlusThings/raw/master/basic_content/vptr_vtable/img/base.jpg)

- 每一个使用虚函数的类和或者从其派生的类都有一个虚函数表，通过维护一个虚函数指针vptr指向该vtable，该vtabel列出了当调用该类的方法时，应该使用基类还是派生类的函数，从而实现了面向对象的重要特性：多态。

## virtual

**虚函数**

- 虚函数的调用取决于指向或引用的对象的类型
- 默认参数是静态绑定的，虚函数是动态绑定的。 默认参数的使用需要看指针或者引用本身的类型，而不是对象的类型

**可以不可以**

- static函数不可声明为virtual也不可以被const和volatile修饰，因为static成员函数不属于任何类或者类示例
- 构造函数不可以是virtual的，因为如果构造函数是虚的，那么它需要vptr来访问，但是此时还没有vptr。
- 析构函数可以声明为虚函数。

## volatile

volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。

const 和指针 都可以是volatile.

```c++
static int i=0;

int main()
{
    while(1)
    {
    if(i) dosomething();
    }
}

/* Interrupt service routine */
void IRS()
{
	i=1;
}
```

如果不给i加上volatile，则编译器会讲该代码优化为死循环，从而导致无法通过外部程序修改i的值从而调用IRS函数。

## assert

- 断言是宏而不是函数
- 忽略断言需要在代码开头加上 `#define NDEBUG`, 需要在`#include <assert.h>`之前。

## 位域

位域通常使用结构体声明， 该结构声明为每个位域成员设置名称，并决定其宽度  [参考](https://github.com/PerhapsChen/CPlusPlusThings/tree/master/basic_content/bit)

## extern

**C与C++编译的区别**（extern "C"）

- `int add(int a, int b)`函数经过C++编译器生成.o文件后，`add`会变成形如`add_int_int`之类的, 而C的话则会是形如`_add`, 就是说：相同的函数，在C和C++中，编译后生成的符号不同。
- 如果C++中使用C语言实现的函数，在编译链接的时候，会出错，提示找不到对应的符号。此时`extern "C"`就起作用了：告诉链接器去寻找`_add`这类的C语言符号，而不是经过C++修饰的符号

## struct和class

**C中的struct**

- C中只能放成员变量，不能放成员函数，且不能加C++修饰符
- C中定义结构变量必须加struct
- C中结构体不能继承，结构体与函数名相同不冲突。

**C++中的struct**

- C++中的结构可以定义数据和函数，也可以被修饰
- C++中结构体使用不用加struct
- 若结构体与函数名相同，可以正常调用，但定义结构体必须加struct

**struct和class**

- 默认的访问控制，struct是public，class是private

## union

联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点

- 默认访问控制符为 public
- 可以含有构造函数、析构函数
- 不能含有引用类型的成员
- 不能继承自其他类，不能作为基类
- 不能含有虚函数
- 匿名 union 在定义所在作用域可直接访问 union 成员
- 匿名 union 不能包含 protected 成员或 private 成员
- 全局匿名联合必须是静态（static）的

## 多态

- C++中的多态:在C++中会维护一张虚函数表，根据赋值兼容规则，我们知道父类的指针或者引用是可以指向子类对象的。

  如果一个父类的指针或者引用调用父类的虚函数则该父类的指针会在自己的虚函数表中查找自己的函数地址，如果该父类对象的指针或者引用指向的是子类的对象，而且该子类已经重写了父类的虚函数，则该指针会调用子类的已经重写的虚函数。

## explicit

- explicit 修饰构造函数时，可以防止隐式转换和复制初始化
- explicit 修饰转换函数时，可以防止隐式转换，但按语境转换除外

## 友元

- 友元函数：普通函数对一个访问某个类中的私有或保护成员。

  友元函数只是一个普通函数，并不是该类的类成员函数，它可以在任何地方调用，友元函数中通过对象名来访问该类的私有或保护成员。

- 友元类：类A中的成员函数访问类B中的私有或保护成员

  友元类的声明在该类的声明中，而实现在该类外。类B是类A的友元，那么类B可以直接访问A的私有成员。

- 友元不存在传递性。

## using

**基本用法**

- 根据当前环境定义宏来选择使用哪个命名空间的函数

**改变访问性**

- 私有继承的时候使用using可以访问父类的私有成员变量（在子类中改变访问类型）

**重载**

- 在继承过程中，派生类可以覆盖重载函数的0个或多个实例，一旦定义了一个重载版本，那么其他的重载版本都会变为不可见。
- 如果对于基类的重载函数，我们需要在派生类中修改一个，又要让其他的保持可见，必须要重载所有版本，这样十分的繁琐。
- 在派生类中使用using声明语句指定一个名字而不指定形参列表，所以一条基类成员函数的using声明语句就可以把该函数的所有重载实例添加到派生类的作用域中。此时，派生类只需要定义其特有的函数就行了，而无需为继承而来的其他函数重新定义。

**取代typedef**

```cpp
typedef std::vector<int> V1; 
using V2 = std::vector<int>;
```

## ::范围解析运算符

- 全局作用域符（::name）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间
- 类作用域符（class::name）：用于表示指定类型的作用域范围是具体某个类的
- 命名空间作用域符（namespace::name）:用于表示指定类型的作用域范围是具体某个命名空间的

## enum

**传统行为**

- 传统枚举作用域不受限，会引起命名冲突

**经典做法**

- C中可以给明明变量前加前缀，但比较繁琐
- C++替代方案是用命名空间，更有效的方法是用类或结构体来限定作用域

```cpp
struct Color1
{
    enum Type
    {
        RED=102,
        YELLOW,
        BLUE
    };
};
```

**C++11枚举类**

**类中的枚举类型**

## decltype

- 用与查询表达式的类型

- 结合auto 用于追踪函数的返回类型
- 如果表达式是一个被重装的函数，则会导致编译错误

## 引用和指针

| 引用         | 指针         |
| ------------ | ------------ |
| 必须初始化   | 可以不初始化 |
| 不能为空     | 可以为空     |
| 不能更换目标 | 可以更换目标 |

**右值引用**

右值引用一定不能被左值所初始化，只能用右值初始化：

```cpp
int x = 20;    // 左值
int&& rrx1 = x;   // 非法：右值引用无法被左值初始化
const int&& rrx2 = x;  // 非法：右值引用无法被左值初始化
```

右值引用可实现转移语义（Move Sementics）和精确传递（Perfect Forwarding），它的主要目的有两个方面：

- 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。
- 能够更简洁明确地定义泛型函数。

C++中的引用只是C++对指针操作的一个“语法糖”，在底层实现时C++编译器实现这两种操作的方法完全相同。

## 宏

**字符串化操作符#**

在一个宏中的参数前面使用一个#,预处理器会把这个参数转换为一个字符数组，换言之就是：#是“字符串化”的意思，出现在宏定义中的#是把跟在后面的参数转换成一个字符串。
