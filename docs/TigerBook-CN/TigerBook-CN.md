# 计算机图形学基础

?> 使用ChatGPT翻译并简单校对虎书：**Fundamentals of Computer Graphics (5th Edition)**  ——Steve Marschner & Peter Shirley

![image-20230516013033825](assets/image-20230516013033825.png)

# 目录 

!> [跳转至正文](#前言)

#### 1. 介绍

- 1.1 图形领域
- 1.2 主要应用
- 1.3 图形APIs
- 1.4 图形管线
- 1.5 数值问题
- 1.6 效率
- 1.7 图形程序的设计与编程

#### 2. 数学杂项

- 2.1 集合和映射
- 2.2 解一元二次方程
- 2.3 三角函数
- 2.4 Vectors 矢量
- 2.5 积分
- 2.6 密度函数
- 2.7 曲线和曲面
- 2.8 线性插值
- 2.9 三角形
- 2.10 离散概率
- 2.11 连续概率
- 2.12 蒙特卡洛积分

#### 3. 光栅图形

- 3.1 光栅设备
- 3.2 图像、像素、几何
- 3.3 RGB颜色
- 3.4 Alpha合成
  

#### 4. 光线追踪

- 4.1 基础光线追踪算法
- 4.2 透视投影
- 4.3 计算观察射线
- 4.4 光线和物体求交
- 4.5 着色
- 4.6 历史注释

#### 5. 表面着色

- 5.1 点光源
- 5.2 基本反射模型
- 5.3 环境照明

#### 6. 线性代数

- 6.1 行列式
- 6.2 矩阵
- 6.3 矩阵和行列式的计算
- 6.4 特征值和矩阵对角化

#### 7. 变换矩阵

- 7.1 2D线性变换
- 7.2 3D线性变换
- 7.3 平移和仿射变换
- 7.4 变换矩阵的逆
- 7.5 坐标转换

#### 8. 视图

- 8.1 视图变换
- 8.2 投影变换
- 8.3 透视投影
- 8.4 透视变换的属性
- 8.5 FOV 视野

#### 9. 图形管线

- 8.1 光栅化
- 8.2 光栅化前后的操作
- 8.3 简单抗锯齿技术
- 8.4 为提高效率而剔除图元

#### 10. 信号处理

- 10.1 数字音频：一维采样
- 10.2 卷积
- 10.3 卷积滤波器
- 10.4 图像信号处理
- 10.5 采样理论

#### 11. 纹理映射

- 11.1 查找纹理值
- 11.2 纹理坐标函数
- 11.3 抗锯齿纹理查找
- 11.4 纹理映射的应用
- 11.5 程序化3D纹理

#### 12. 图形数据结构

- 12.1 三角网格
- 12.2 场景图
- 12.3 空间数据结构
- 12.4 BSP树可见性
- 12.5 多维数组平铺

#### 13. 采样

- 13.1 积分
- 13.2 连续概率
- 13.3 蒙特卡洛积分
- 13.4 随机点选择

#### 14. 基于物理的渲染 PBR

- 14.1 光子
- 14.2 光滑金属
- 14.3 逛花街之
- 14.4 次表面散射介质
- 14.5 暴力光子追踪器
- 14.6 辐射度量学
- 14.7 散射辐射度量学
- 14.8 输运方程
- 14.9 实践中的材质
- 14.10 蒙特卡洛光线追踪

#### 15. 曲线

- 15.1 曲线
- 15.2 曲线属性
- 15.3 多项式片段
- 15.4 拼接多项式片段
- 15.5 立方体
- 15.6 近似曲线
- 15.7 总结

#### 16. 计算机动画

- 16.1 动画原理
- 16.2 关键帧
- 16.3 形变
- 16.4 角色动画
- 16.5 基于物理的动画
- 16.6 程序化技术
- 16.7 对象组合

#### 17. 使用图形硬件

- 17.1 硬件概述
- 17.2 图形硬件是什么
- 17.3 异构多处理器系统
- 17.4 图形硬件编程：缓冲区、状态和着色器
- 17.5 状态机
- 17.6 基本的OpenGL应用程序
- 17.7 几何体
- 17.8 着色器初见
- 17.9 顶点缓冲对象 VBO
- 17.10 顶点数组对象 VAO
- 17.11 变换矩阵
- 17.12 使用顶点属性着色
- 17.13 使用片段处理器着色
- 17.14 网格和实例化
- 17.15 纹理对象
- 17.16 面向对象设计图形硬件编程
- 17.17 持续学习...

#### 18. 色彩

- 18.1 Colorimetry 色度学
- 18.2 色彩空间
- 18.3 色适应性
- 18.4 颜色外观

#### 19. 视知觉

- 19.1 视觉科学
- 19.2 视敏度
- 19.3 空间视觉
- 19.4 物体、位置和事件
- 19.5 图像感知

#### 20. 色调重建

- 20.1 分类
- 20.2 动态范围
- 20.3 颜色
- 20.4 图像生成
- 20.5 基于频率的运算符
- 20.6 梯度频域运算符
- 20.7 空间运算符
- 20.8 Division
- 20.9 Sigmoid
- 20.10 其他方法
- 20.11 Night 色调映射
- 20.12 讨论

#### 21. 隐式模型

- 21.1 隐式函数、骨架图元及求和混合
- 21.2 渲染
- 21.3 空间划分
- 21.4 Blending 混合
- 21.5 构造实体节化学 CSG
- 21.6 弯曲变形
- 21.7 精确接触建模
- 21.8 Blob Tree
- 21.9 交互隐式建模系统

#### 22. 游戏中的计算机图形学

- 22.1 平台
- 22.2 有限的资源
- 22.3 优化计算
- 22.4  游戏类型
- 22.5 游戏制作流程

#### 23. 可视化

- 23.1 背景
- 23.2 数据类型
- 23.3 以人为本的设计过程
- 23.4 视觉编码原则
- 23.5 交互原则
- 23.6 组合和相邻视图
- 23.7 减少数据
- 23.8 示例

# 前言

《计算机图形学基础》这一版本在**着色、光反射和路径追踪**等方面进行了大量重写，并进行了许多修正。现在，本书更好地介绍了以物理为基础的材料和渲染技术，这些技术正在实际应用中变得越来越普遍。此内容现已更好地整合，我们认为本书与目前许多教师组织图形课程的方式相吻合。

本书的组织结构与第四版基本相似。随着多年来对本书的修订，我们努力保留早期版本所具有的非正式、直观风格的表达方式，同时提高其一致性、精度和完整性。我们希望读者能够发现结果是一个适用于各种计算机图形学课程的吸引人平台。

## 关于封面

封面图片来自J.W.贝克的《水中的老虎》（丙烯刷和喷笔在画布上，16英寸乘20英寸，www.jwbart.com ）  。

老虎是指阿兰·福尔尼耶（1943-2000）在1998年康奈尔大学的一个研讨会上发表过精彩演讲。他生动地描述了老虎的动作，并总结了他的观点。

- 尽管计算机图形学中的建模和渲染在过去35年里得到了极大的改进，但我们仍然无法自动地以所有细节呈现老虎在河中游泳。所谓自动化是指不需要艺术家/专家进行精细手工调整的方式。

- 坏消息是我们还有很长的路要走。

- 好消息是我们还有很长的路要走。

## 作者

**Steve Marschner**是康奈尔大学计算机科学教授。他于1993年在布朗大学获得了Sc.B.学位，并于1998年在康奈尔大学获得了博士学位。他曾在微软研究院和斯坦福大学担任研究职务，于2002年加入康奈尔大学。他荣获2015年SIGGRAPH计算机图形成就奖，并与其他人共同获得2003年技术奥斯卡。

**Peter Shirley**是NVIDIA杰出研究科学家。他曾在印第安纳大学、康奈尔大学和犹他州立大学担任教职。1985年，他从里德學院取得物理學文學士學位，在1991年从伊利诺伊州立大學取得計算機科學博士。

# 1 引言

计算机图形学是指使用计算机来创建和操作图像的任何方式。本书介绍了可以用于创建各种类型图像（逼真的视觉效果、信息化技术插图或美丽的计算机动画）的算法和数学工具。图形可以是二维或三维，图片可以完全合成或通过操纵照片产生。本书主要讲解基础算法和数学知识，特别是用于生成三维物体和场景合成图像的知识。

实际进行计算机图形处理需要了解特定硬件、文件格式以及通常需要一个或两个图形API（参见第1.3节）。由于计算机图形学领域正在快速发展，因此这些知识点也在不断变化中。因此，在本书中我们尽力避免依赖任何特定硬件或API，并鼓励读者根据其软件和硬件环境补充相关文档资料。幸运的是，计算机图形领域有足够标准化术语和概念，使得本书内容应该能够很好地映射到大多数环境。

?> API：应用程序接口。

本章定义了一些基本术语，并提供了与计算机图形相关的历史背景和信息来源。

## 1.1 图形领域

在任何领域中强加类别都是危险的，但大多数图形从业者会同意计算机图形学的以下主要领域：

- **模型**以一种可以存储在计算机上的方式数学地规定形状和外观属性。例如，一个咖啡杯可以被描述为一组有序的三维点连同某些插值规则来连接这些点和一个反射模型来描述光如何与杯子相互作用。
- **渲染**是从艺术中继承而来的术语，它涉及从3D计算机模型创建阴影图像。
- **动画**是通过图像序列创建运动幻象的技术。动画使用建模和渲染，但增加了关键问题——随时间移动——这通常不在基本建模和渲染中处理。

还有许多其他涉及计算机图形学的领域，它们是否是核心图形学领域则因人而异。这些相关领域都将在本文中至少被提到。这些相关领域包括以下几个方面：

- **用户交互**处理输入设备（如鼠标和平板电脑）、应用程序、反馈给用户的影像以及其他感官反馈之间的接口。历史上，由于图形研究人员最早可以使用现在无处不在的输入/输出设备，所以该领域与图形学密切相关。
- **虚拟现实**试图将用户沉浸到一个三维虚拟世界中。这通常需要至少立体声图形和对头部运动的响应。为了实现真正的虚拟现实，还应该提供声音和力反馈等功能。由于此领域能够利用先进的3D图形技术和高级显示技术，因此通常与计算机图形学紧密关联。
- **可视化**试图通过可视化展示来帮助用户理解复杂信息问题，并经常需要解决一些与计算机制画有关的问题。
- **图像处理**涉及2D图片操作，并广泛应用于计算机制画和视觉等领域。
- **3D扫描**使用测距技术创建测量的三维模型。这些模型对于创建丰富的视觉图像非常有用，处理此类模型通常需要计算机图形学算法。
- **计算摄影**是利用计算机图形学、计算机视觉和图像处理方法，以实现对物体、场景和环境进行新型摄影捕捉的技术。

## 1.2 主要应用

几乎任何事业都可以利用计算机图形学，但是主要的计算机图形技术消费者包括以下行业：

- **电子游戏**越来越多地使用复杂的3D模型和渲染算法。
- **卡通**经常直接从3D模型中呈现。许多传统2D卡通使用从3D模型渲染的背景，这允许连续移动视点而不需要大量艺术家时间。
- **视觉效果**几乎使用所有类型的计算机图形技术。几乎每部现代电影都使用数字合成将背景与单独拍摄的前景叠加在一起。许多电影还使用3D建模和动画来创建合成环境、物体甚至角色，大多数观众永远不会怀疑它们不是真实存在的。
- **动画电影**使用了很多用于视觉效果的相同技术，但并非必须针对看起来真实的图像。
- **CAD/CAM**代表计算机辅助设计和制造。这些领域利用计算机技术在计算机上设计零件和产品，并且然后通过这些虚拟设计指导制造过程。例如，许多机械零件是在3D计算机建模软件中设计的，然后自动在计算机控制的铣削设备上生产。
- **模拟**可以被认为是准确的视频游戏。例如，飞行模拟器使用复杂的3D图形来模拟驾驶飞机的体验。这样的模拟对于安全关键领域（如驾驶）中的初始培训以及针对经验丰富用户（如特定消防情况）进行场景培训非常有用，因为这些情况过于昂贵或危险而无法物理创建。
- **医学影像技术**可以创建扫描患者数据的有意义的图像。例如，计算机断层扫描（CT）数据集由大量三维矩形密度值数组组成。计算机图形学用于创建阴影图像，帮助医生从这些数据中提取最重要的信息。
- **信息可视化**可以创建不一定具有“自然”视觉呈现方式的数据图像。例如，十种不同股票价格的时间趋势没有明显的视觉呈现方式，但巧妙的绘图技术可以帮助人们看到这些数据中的模式。

## 1.3 图形APIs

使用图形库的关键部分是处理图形API。应用程序接口（API）是一组标准函数，用于执行一组相关操作，而图形API则是一组函数，可在屏幕上的窗口中绘制图像和3D表面等基本操作。

每个图形程序都需要能够使用两个相关的API：一个用于视觉输出的图形API和一个用于从用户获取输入的用户界面API。目前有两种主要的图形和用户界面API范例。第一种是集成方法，例如Java，在这种方法中，图形和用户界面工具包被集成为便携式软件包，并作为语言的完全标准化和支持部分提供。第二种由`Direct3D`和`OpenGL`代表，在这里绘画命令是与诸如C++之类语言捆绑在一起的软件库的一部分，并且用户界面软件是独立实体，可能因系统而异。在后者方法中编写可移植代码存在问题，尽管对于简单程序来说可能可以使用便携式库层来封装特定于系统的用户界面代码。

无论您选择哪种API，基本图形调用将大致相同，并且本书所介绍到概念也适用。

## 1.4 渲染管线

现今每台桌面电脑都拥有强大的3D图形管线。这是一个特殊的软件/硬件子系统，能够高效地以透视方式绘制3D基元。通常这些系统被优化为处理具有共享顶点的3D三角形。**管线中的基本操作将3D顶点位置映射到2D屏幕位置**，并对三角形进行着色，使其既看起来逼真又按正确的前后顺序出现。

尽管在计算机图形学中，以有效的反向顺序绘制三角形曾经是最重要的研究问题之一，但现在几乎总是使用**z缓冲**区来解决这个问题。它使用特殊的内存缓冲区以暴力方式解决该问题。

事实证明，在图形管道中使用的几何操作可以几乎完全在由三个传统几何坐标和第四个齐次坐标组成的4D坐标空间中完成，后者有助于透视查看。这些4D坐标使用4×4矩阵和4向量进行操作。因此，图形管线包含了大量用于高效处理和组合这些矩阵和向量的机器设备。这种4D坐标系统是计算机科学中最微妙、最美丽的构造之一，并且当学习计算机图形学时肯定是最大的智力障碍。每本图形书籍前面很大一部分都涉及到这些坐标。

生成图片速度取决于正在绘制三角形数量。因为交互性对许多应用程序比视觉质量更重要，所以值得将用于表示模型的三角形数量最小化。此外，如果从远处查看模型，则需要较少的三角形，而从较近距离查看模型则需要更多的三角形。这表明使用不同级别的细节（LOD）表示模型是有用的。

## 1.5 数值问题

许多图形程序实际上只是3D数值代码。在这些程序中，数字问题通常至关重要。在“旧日子”里，以鲁棒和可移植的方式处理此类问题非常困难，因为机器对于数字有不同的内部表示，并且更糟糕的是，在不同和不兼容的方式下处理异常情况。幸运的是，几乎所有现代计算机都符合IEEE浮点标准（IEEE Standards Association, 1985）。这使得程序员可以对某些数字条件将如何处理做出许多方便的假设。

虽然IEEE浮点具有许多编码数字算法时有价值的特性，但大多数图形遇到的情况只需要了解其中很少一部分即可。首先并且最重要的是要理解，在IEEE浮点中存在三个实数“特殊”值：

1. 无穷大 (∞)。这是一个有效的数字，它比所有其他有效数字都要大。
2. 负无穷（-∞）。这是一个有效的数字，比所有其他有效数字都要小。
3. 非数字（NaN）。这是一种无效的数字，由于操作具有未定义后果而产生，例如零除以零。

!> IEEE浮点数有两种表示方法来表示0，一种被视为正数，另一种被视为负数。-0和+0之间的区别只有在极少数情况下才会产生影响，但应该记住这些场合。

IEEE浮点数的设计者做出了一些对程序员非常方便的决策。其中许多与处理诸如除以零等异常情况中上述三个特殊值有关。在这些情况下，会记录异常，但在许多情况下，程序员可以忽略它们。具体而言，在任何正实数a的情况下，IEEE浮点数在处理除无穷大值时遵循以下规则：
$$
+a/(+\infty)=+0, \\
-a/(+\infty)=-0, \\
+a/(-\infty)=-0, \\
-a/(-\infty)=+0.
$$
涉及无限值的其他操作表现出人们所期望的行为。再次针对正数a，其行为如下：
$$
\infty+\infty=+\infty, \\
-\infty-\infty=\mathrm{NaN}, \\
\infty\times\infty=+\infty, \\
\infty/\infty=+\infty, \\
\infty/a=\infty, \\
\infty/0=\infty, \\
0/0 = \mathrm{NaN}
$$
涉及无限值的布尔表达式规则如下：
1. 所有有限有效数字都小于+∞。
2. 所有有限有效数字都大于-∞。
3. -∞小于+∞。

涉及NaN值的表达式规则很简单：

1. 包括NaN的任何算术表达式结果为NaN。
2. 任何涉及NaN的布尔表达式均为false。

IEEE浮点数最有用的方面可能是如何处理除以零；对于任何正实数a，涉及除以零值的以下规则成立：
$$
+a/+0=+\infty, \\
-a/+0=-\infty.
$$
如果程序员利用IEEE规则，许多数字计算会变得更简单。例如，考虑以下表达式：
$$
a=\frac{1}{\frac{1}{b}+\frac{1}{c}}
$$
这种表达式常出现在电阻和透镜中。如果除以零导致程序崩溃（在IEEE浮点数之前的许多系统中都是如此），那么需要两个if语句来检查b或c的小值或零值。相反，在IEEE浮点数中，如果b或c为零，则我们将得到所需的a的零值。避免特殊检查的另一种常见技术是利用NaN的布尔属性。考虑以下代码段：

```bash
a = f(x)
if (a > 0) then
	do something
```

在这里，函数f可能会返回“丑陋”的值，如∞或NaN，但if条件仍然是明确定义的：对于$a=NaN$或$a=-∞$为false，而对于$a=+∞$则为true。通过谨慎地决定返回哪些值，通常可以使if做出正确的选择，并且不需要进行特殊检查。这使得程序更小、更健壮、更高效。

## 1.6 效率

没有制定代码更高效的魔法规则。通过仔细权衡来实现效率，而这些权衡对于不同的架构是不同的。然而，在可预见的未来，一个好的启发式方法是程序员应该更加关注内存访问模式而不是操作计数。这与二十年前最佳启发式方法相反。之所以出现了这种转变，是因为**内存速度没有跟上处理器速度**的步伐。由于这一趋势持续存在，有限和连贯内存访问对于优化的重要性只会增加。

使代码快速运行的合理方法是按照以下顺序进行，并仅采取必要步骤：

1. 以最简单的方式编写代码。根据需要即时计算中间结果，而不是将它们存储下来。
2. 在优化模式下进行编译。
3. 使用任何可用的分析工具查找关键瓶颈。
4. 检查数据结构以寻找提高局部性能力的方法。如果可能，请使数据单元大小与目标架构上的缓存/页面大小匹配。
5. 如果分析揭示了数字计算方面的瓶颈，请检查编译器生成的汇编代码是否存在效率问题。重写源代码以解决发现的任何问题。

这些步骤中最重要的是第一步。大多数“优化”会使代码难以阅读，而并没有提高速度。此外，事先花费时间来优化代码通常比纠正错误或添加功能更好。另外，要注意旧文本中的建议；有些经典技巧（如使用整数代替实数）可能不再具有加速作用，因为现代CPU通常可以像执行整数操作一样快地执行浮点运算。在所有情况下，都需要进行分析以确保任何针对特定机器和编译器的优化都是值得的。

## 1.7 设计和编写图形程序
在图形编程中，通常有一些常见的策略是非常有用的。本节提供了一些建议，希望您在实现本书中学习到的方法时会发现这些建议很有帮助。

### 1.7.1 类设计

任何图形程序的关键部分都是拥有良好的几何实体类或例程，例如向量和矩阵，以及图形实体类如RGB颜色和图像。这些例程应尽可能地简洁高效。一个普遍的设计问题是位置和位移是否应该作为不同的类来处理，因为它们具有不同的操作，例如将位置乘以一半没有几何意义，而将位移乘以一半则有（Goldman, 1985; DeRose, 1989）。对于这个问题并没有达成共识，在图形从业者之间可能会引发数小时激烈辩论，但为了举例说明，我们假设我们不会进行区分。

这意味着需要编写一些基本类，包括：

- `vector2`。一个二维向量类，存储x和y分量。它应该将这些分量存储在长度为2的数组中，以便支持索引运算符。您还应该包括向量加法、向量减法、点积、叉积、标量乘法和标量除法等操作。
- `vector3`。类似于vector2的三维向量类。
- `hvector`。具有四个分量的齐次向量（参见第7章）。
- `rgb`。存储三个分量的RGB颜色。您还应该包括RGB加法、RGB减法、RGB乘法、标数量乘和标数量除等操作。
- `transform`。用于变换的4×4矩阵。您应该包括一个矩阵乘积和成员函数来应用于位置、方向和表面法线向量上，在第6章中已经展示了它们是不同的。
- `image`. 具有输出操作的RGB像素二维数组。

此外，您可能会或可能不想添加间隔区域（intervals）、正交规范基（orthonormal bases）和坐标框架（coordinate frames）等其他类。

!> 你可能还需要考虑一下针对单位向量的特殊类，尽管我发现它们带来的麻烦比价值更大。——P.S.

### 1.7.2 Float vs Double

现代架构表明，保持内存使用率低和维护一致的内存访问是提高效率的关键。这意味着使用单精度数据。然而，避免数值问题则建议使用双精度算术。权衡取决于程序，但在类定义中设置默认值很好。

!> 我建议在几何计算中使用双精度浮点数，而在颜色计算中使用单精度浮点数。对于占用大量内存的数据，例如三角形网格，我建议存储单精度浮点数数据，并在通过成员函数访问数据时转换为双精度。——P.S.

!> 我主张在进行所有计算时都使用浮点数，直到你发现代码的特定部分需要双精度为止。——S.M.

### 1.7.3 图形程序Debugging

如果你询问一下，你可能会发现随着程序员经验的增加，他们使用传统的调试器越来越少。其中一个原因是对于复杂的程序而言，使用这样的调试器比简单程序更麻烦。另一个原因是最困难的错误是概念性错误，在实现错误时很容易浪费大量时间逐步查看变量值而未能检测到此类情况。我们发现在图形学中有几种调试策略特别有用。

#### 科学方法

在图形程序中，有一种传统调试的替代方法通常非常有用。它的缺点是与计算机程序员早期职业生涯所教授的内容非常相似，因此如果您这样做可能会感到“不道德”：我们创建一个图像并观察其中存在什么问题。然后，我们提出一个关于问题原因的假设并进行测试。例如，在光线追踪程序中，我们可能会遇到许多看起来有些随意、黑暗像素点。这是大多数人编写光线追踪器时遇到的经典“阴影痤疮”问题。传统调试在这里没有帮助；相反，我们必须意识到阴影射线正在击中被着色表面上。我们可能会注意到黑斑点的颜色是环境颜色，因此直接照明缺失了。可以关闭阴影下的直接照明检查，以便您可以假设这些点被错误地标记为处于阴影之中而实际上却不是如此。要测试该假设，则可以关闭阴影检查并重新编译代码以确定是否存在虚假阴影测试，并继续进行调试工作即可。

使用该方法成为良好实践主要原因是我们无需发现错误值或真正确定概念性错误。相反，我们只需要通过实验逐步缩小问题范围并找到概念性错误。通常只需要进行几次试验即可追踪问题，并且这种调试方式非常有趣。

#### 将图像作为编码调试输出
在许多情况下，从图形程序中获取调试信息的最简单渠道就是输出图像本身。如果您想了解某些变量的值，以便针对每个像素运行的计算部分进行调试，则可以暂时修改程序，直接将该值复制到输出图像中，并跳过通常要执行的其余计算。例如，如果您怀疑表面法线存在问题导致着色出现问题，则可以直接将法向量复制到图像中（x 轴转换为红色、y 轴转换为绿色、z 轴转换为蓝色），从而得到一个彩色编码描绘实际用于计算的向量。或者，如果您怀疑特定值有时超出其有效范围，请让程序在发生这种情况时写入鲜艳的红色像素。其他常见技巧包括使用明显颜色绘制表面背面（当它们不应该可见时）、通过对象 ID 号对图像进行着色或根据计算所需工作量对象来着色。

#### 使用调试器
在某些情况下，特别是当科学方法似乎导致矛盾时，观察正在发生的事情是无可替代的。问题在于，图形程序通常涉及许多相同代码的执行（例如每个像素一次或每个三角形一次），使得从头开始通过调试器逐步执行变得完全不切实际。而且最困难的错误通常只会出现在复杂输入中。

一个有用的方法是为错误设置“陷阱”。首先，请确保您的程序具有确定性-在单个线程中运行它，并确保所有随机数都从固定种子计算。然后，找出哪个像素或三角形展示了该错误，并在您怀疑不正确的代码之前添加一个语句，仅针对嫌疑案例执行。例如，如果您发现像素（126,247）显示了该错误，则添加：

```bash
if x = 126 and y = 247 then
	print "blarg!"
```

如果您在打印语句上设置断点，就可以在计算所需像素之前进入调试器。一些调试器具有“条件断点”功能，可以在不修改代码的情况下实现相同的效果。

对于程序崩溃的情况，传统的调试器非常有用，可以准确定位崩溃位置。然后应该使用assert和重新编译来回溯程序，找出程序出错的地方。这些assert应该留在程序中以备将来可能添加的错误。这意味着避免了传统的逐步过程，因为那样做不能为您的程序添加宝贵的assert。

!> 使用固定的随机数种子的特殊调试模式非常有用。

#### 数据可视化用于调试
通常情况下，很难理解程序在做什么，因为它会计算许多中间结果，最终才出现错误。这种情况类似于进行大量数据测量的科学实验，并且有一个相同的解决方案：为自己制作良好的图表和插图以了解数据含义。

例如，在光线追踪器中，您可以编写代码来可视化射线树，以便查看哪些路径对像素产生了贡献；或者在图像重采样例程中，您可以制作显示从输入获取样本点的所有点的图表。花费时间编写代码来可视化程序内部状态也将回报更好地理解其行为，并优化它时节省时间。

!> 我喜欢将调试的打印语句格式化，以便输出成为Matlab或Gnuplot脚本，从而生成有用的图形。——S.M.

## 注释

软件工程的讨论受到了Effective C++系列（Meyers，1995年，1997年），极限编程运动（Beck＆Andres，2004年）和Programming Practice（Kernighan＆Pike， 1999）的影响。实验性调试的讨论基于与Steve Parker的讨论。

有许多与计算机图形相关的年度会议，包括ACM SIGGRAPH和SIGGRAPH Asia、Graphics Interface、Game Developers Conference (GDC)、Eurographics、Pacific Graphics、High Performance Graphics、Eurographics渲染研讨会以及IEEE VisWeek等。这些可以通过网络搜索轻松找到。



# 2 数学杂项

很多图形学都是将数学直接转化为代码。数学越干净，生成的代码就越干净；因此本书大部分内容都集中在使用恰当的数学知识来完成工作上。本章回顾了高中和大学数学中的各种工具，并旨在作为参考资料而非教程使用。它可能看起来像一堆杂乱无章的主题，确实如此；每个主题之所以被选择，是因为它在“标准”数学课程中有些不寻常，在图形处理方面至关重要或者通常没有从几何角度进行讨论。除了建立本书所用符号的复习外，该章还强调了一些标准本科课程有时会忽略掉的点，例如三角形质心坐标系等。这一章并不打算对材料进行严格处理；相反地，注重直觉和几何解释。线性代数讨论推迟到第5章，在矩阵变换之前进行讨论。鼓励读者浏览本章以熟悉涵盖的主题，并根据需要参考它。该章末尾练习可帮助确定哪些主题需要温习复习。

## 2.1 集合和映射

映射，也称为函数，在数学和编程中都是基础概念。就像程序中的函数一样，数学中的映射接受一个特定类型的参数，并将其映射到（返回）一个特定类型的对象。在程序中我们说“类型”，而在数学中我们会确定集合。当我们有一个属于某个集合的对象时，我们使用∈符号表示。例如：
$$
a\in  \mathbf{S}
$$
”$a$是集合$\mathbf{S}$的成员。”给定任意两个集合$\mathbf{A}$和$\mathbf{B}$，我们可以通过取两个集合的笛卡尔积来创建第三个集合，表示为$\mathbf{A}\times\mathbf{B}$。这个由所有可能的有序对(a, b)组成的集合$\mathbf{A}\times\mathbf{B}$，其中$a\in \mathbf{A}$且$b\in \mathbf{B}$。作为一种简写方式，我们使用符号$\mathbf{A}^2$来表示$\mathbf{A}\times\mathbf{A}$。我们可以将笛卡尔积扩展到从三个集合中获取所有可能的有序三元组等任意长有序元组和任意多个集。

常见的兴趣集包括：

- $\mathbb{R}$ 实数；
- $\mathbb{R}^+$ 非负实数（包括零）；
- $\mathbb{R}^2$ 有序对在真正的二维平面上；
- $\mathbb{R}^n$-n维笛卡尔空间中的点；
- $\mathbb{Z}$-整数；
- $\mathbf{S}^2$-单位球面上的三维点（$\mathbb{R}^3$中的点）。

请注意，虽然$\mathbf{S}^2$由嵌入三维空间中的点组成，但它们位于可以用两个变量参数化的表面上，因此可以将其视为二维集合。映射符号使用箭头和冒号，例如：
$$
f:\mathbb{R}\mapsto\mathbb{Z}
$$
你可以将其理解为“有一个名为f的函数，它接受实数作为输入并将其映射到整数。” 这里，箭头前面的集合被称为函数的定义域，右侧的集合被称为目标值。计算机程序员可能更喜欢以下等价语言：“有一个名为 $f$ 的函数，它具有一个实参并返回一个整数。” 换句话说，上述集合符号与常见编程符号是等价的：
$$
\mathrm{integer}\ f(\mathrm{real}) \leftarrow \mathrm{equivalent}\rightarrow f:\mathbb{R}\mapsto\mathbb{Z}
$$
因此，冒号箭头符号可以被视为一种编程语法。就是这么简单。

点 $f(a)$ 称为 $a$ 的像，集合$A$（定义域的子集）的像是包含所有$A$中点的像所构成的目标集合的子集。整个定义域的像称为函数的值域。

### 2.1.1 逆映射

!> 略

### 2.1.2 区间

!> 略

### 2.1.3 对数

!> 略

## 2.2 解一元二次方程

!> 略

## 2.3 三角函数

!> 略

**正弦定理：**
$$
\frac{\sin A}{a}=\frac{\sin B}{b}=\frac{\sin C}{c}
$$
**余弦定理：**
$$
c^2=a^2+b^2-2ab\cos C
$$
**正切定理：**
$$
\frac{a+b}{a-c}=\frac{\tan\frac{A+B}{2}}{\tan\frac{A-B}{2}}
$$
**三角形面积：**
$$
S=\frac{1}{4}\sqrt{(a+b+c)(-a+b+c)(a-b+c)(a+b-c)}
$$

## 2.4 向量

点积 Dot Product
$$
\mathbf{a}\cdot\mathbf{b}=\left\lVert a\right\rVert \left\lVert b\right\rVert \cos\phi
$$
叉积 Cross Product
$$
\left\lVert a\times b\right\rVert=\left\lVert a\right\rVert \left\lVert b\right\rVert \sin\phi
$$

## 2.5 积分

## 2.6 密度函数

## 2.7 曲线和曲面

## 2.8 线性插值

## 2.9 三角形 ★

在许多图形程序中，无论是2D还是3D三角形都是基本的建模原语。通常，诸如颜色之类的信息被标记到三角形顶点上，并且这些信息会在整个三角形内插值。使得这种插值变得简单直接的坐标系称为重心坐标系；我们将从头开始开发它们。我们还将讨论2D三角形，在绘制它们在2D屏幕上的图片之前必须理解。

### 2.9.1 2D三角形

如果我们有一个由二维点a、b和c定义的二维三角形，我们可以先找到它的面积：
$$
\mathrm{Area}=\frac{1}{2}\begin{vmatrix}
x_b-x_a & x_c-x_a \\
y_b-y_a & y_c-y_a \\
\end{vmatrix}
$$
这个公式的推导可以在第6.3节中找到。如果点a、b和c按逆时针顺序排列，则该区域将具有正号；否则，它将具有负号。

在图形学中，我们经常希望在每个三角形顶点上分配属性（例如颜色），并在整个三角形上平滑地插值该属性的值。有多种方法可以实现这一点，但最简单的方法是使用**重心坐标系**。可以将重心坐标系看作非正交坐标系，如第2.4.2节中简要讨论过的那样。这样的坐标系显示在图2.38中，其中坐标原点为a，从a到b和c的向量是基向量。通过该原点和基向量，任何点p都可以写成
$$
\mathrm{p}=\mathrm{a}+\beta(\mathrm{b-a})+\gamma\mathrm{(c-a)} \qquad \mathrm{(2.28)}
$$
![image-20230518223412309](assets/image-20230518223412309.png)

**图2.38** 一个由顶点a、b、c组成的二维三角形可以用来建立一个非正交坐标系，其中原点为a，基向量为(b-a)和(c-a)。一个点可以表示为有序对(β, γ)。例如，点p=(2.0, 0.5)，即p=a+2.0(b-a)+0.5(c-a)。



请注意，我们可以重新排列方程（2.28）中的项，以得到：
$$
\mathrm{p}=(1-\beta-\gamma)\mathrm{a}+\beta\mathrm{b}+\gamma\mathrm{c}
$$
通常人们会定义一个新变量α来改善方程的对称性：
$$
\alpha=1-\beta-\gamma
$$
所以得到
$$
\mathrm{p}(\alpha,\beta,\gamma)=\alpha\mathrm{a}+\beta\mathrm{b}+\gamma\mathrm{c}
$$
在限制条件下:
$$
\alpha+\beta+\gamma=1
$$
重心坐标一开始似乎是一个抽象和不直观的概念，但它们被证明是强大而方便的。你可能会发现，在一个有两组平行街道但这些街道并非成直角的城市中，如何使用街道地址很有用。自然系统本质上就是重心坐标系，你很快就会习惯它们。重心坐标适用于平面上所有点。其中一个特别好的特性是：**当且仅当点p在由a、b和c形成的三角形内部时，它才位于该三角形内部：**
$$
0<\alpha<1,\\
0<\beta<1,\\
0<\gamma<1.
$$
如果其中一个坐标为零，而另外两个坐标在零和一之间，则您位于边缘。如果两个坐标为零，则另一个为一，您就在顶点上。

重心坐标的另一个好处是方程式（2.29）实际上以平滑的方式混合了三个顶点的坐标。相同的混合系数（α、β、γ）可以用于混合其他属性，例如颜色，我们将在下一章中看到。给定一个点p，如何计算其重心坐标？一种方法是将方程式（2.28）写成带有未知数β和γ的线性系统，并解决并设置α = 1-β-γ。该线性系统为
$$
\begin{bmatrix}
x_b-x_a & x_c-x_a \\
y_b-y_a & y_c-y_a \\
\end{bmatrix}
\begin{bmatrix} \beta\\\gamma \end{bmatrix}=
\begin{bmatrix} x_p-x_a\\ y_p-y_a \end{bmatrix}
$$
虽然用代数方法解上面的矩阵方程很简单，但直接计算几何解通常更为有效。

重心坐标的一个几何特性是它们是**三角形边线上点的带符号缩放距离**，如图2.39所示。回想一下第2.7.2节中提到的，对于方程$f(x,y)=0$表示的直线，计算$f(x,y)$在点$(x,y)$处的值可以得到该点到直线的带符号距离。同时也要记住，如果$f(x,y)=0$是某条特定直线的方程，则$kf(x,y)=0$对于任意非零$k$也是这条直线的方程。改变$k$会缩放距离并控制哪一侧具有正带符号距离和哪一侧具有负带符号距离。我们想选择一个k使得例如$kf (x, y) = β$成立。由于只有一个未知数$k$，我们可以通过一个约束条件来强制实现这个目标，在b点处我们知道$β=1$。因此如果$f_{ac}(x,y)=0$表示经过$a$和$c$两个点，则我们可以按以下方式计算出点$（x,y）$ 的$β$：
$$
\beta=\frac{f_{ac}(x,y)}{f_{ac}(x_b,y_b)}
$$
我们可以以类似的方式计算$γ$和$α$。为了提高效率，通常最好直接计算两个重心坐标，并根据三个坐标值和为1计算第三个坐标。

要找到通过$p_0$和$p_1$的线段的“理想”形式，我们可以首先使用顶点隐式线段：
$$
f_{a,b}(x,y)=(y_a-y_b)x+(x_b-x_a)y+x_ay_b-x_by_a=0.
$$
请注意，$f_{a,b}(x_c,y_c)$可能不等于1，因此它可能不是我们寻找的理想形式。通过除以$f_{a,b}(x_c,y_c)$，我们得到
$$
\gamma=\frac{(y_a-y_b)x+(x_b-x_a)y+x_ay_b-x_by_a}{(y_a-y_b)x_c+(x_b-x_a)y_c+x_ay_b-x_by_a}
$$
![image-20230518230317589](assets/image-20230518230317589.png)

**图2.39**  重心坐标β是点a和c所在直线上的有向距离。



除法的存在可能会让我们担心，因为这会引入除以零的可能性，但是对于面积不接近零的三角形来说，这种情况不会发生。α和β也有类似的公式，但通常只需要一个：
$$
\beta=\frac{(y_a-y_c)x+(x_c-x_a)y+x_ay_c-x_cy_a}{(y_a-y_c)x_c+(x_c-x_a)y_c+x_ay_c-x_cy_a}
$$

$$
\alpha=1-\beta-\gamma
$$

计算重心坐标的另一种方法是计算子三角形的面积$A_a、A_b和A_c$，如图2.40所示。重心坐标遵守以下规则：

![image-20230518230253773](assets/image-20230518230253773.png)

**图2.40** 重心坐标与三个子三角形的面积成比例。
$$
\alpha=\frac{A_a}{A}
$$

$$
\beta=\frac{A_b}{A}
$$

$$
\gamma=\frac{A_c}{A}
$$

其中A是三角形的面积。请注意，$A = A_a + A_b + A_c$，因此可以通过两次加法而不是完整的面积公式来计算。如果允许区域带符号，**则该规则仍适用于三角形外部的点**。其原因如图2.41所示。请注意，这些都是带符号的区域，并且只要对$A$和子三角形$A_a、A_b和A_c$使用相同的带符号区域计算即可正确计算。

![image-20230518230843186](assets/image-20230518230843186.png)

**图2.41** 所示两个三角形的面积均为底边乘以高度的一半，因此与任何一个顶点在$β = 0.5$线上的三角形相同。高度和面积与$β$成比例。

### 2.9.2 3D三角形

重心坐标的一个奇妙之处在于它们几乎可以透明地扩展到三维空间。如果我们假设点a、b和c是三维的，那么我们仍然可以使用这种表示方法。
$$
\mathrm{p}=(1-\beta-\gamma)\alpha+\beta\mathrm{b}+\gamma\mathrm{c}
$$
现在，当我们改变 $β和γ$ 时，相当于扫过一个平面。

三角形的法向量可以通过取三角形所在平面上任意两个向量的叉积来找到。最容易使用其中两条边作为这些向量，例如：
$$
\mathrm{n=(b-a)\times(c-a)}  \qquad\qquad(2.34)
$$
请注意，这个法向量不一定是单位长度的，并且它遵循叉积的右手规则。

![image-20230518231211102](assets/image-20230518231211102.png)

**图2.42** 三角形的法向量垂直于三角形所在平面内的所有向量，因此也垂直于三角形的边。

三角形的面积可以通过取叉积长度来计算：
$$
\mathrm{Area=\frac{1}{2}||(b-a)\times(c-a)||}
$$
请注意，这不是一个有符号的面积，因此不能直接用于计算重心坐标。然而，我们可以观察到，“顺时针”顶点顺序的三角形法向量指向与“逆时针”顶点顺序相反方向的同一平面内三角形法向量。回想一下：
$$
\mathrm{a\cdot b=||a||\thinspace||b||\cos\phi}
$$
其中 ϕ 是向量之间的夹角。如果 a 和 b 平行，则 cos ϕ = ±1，这可以测试向量指向相同方向还是相反方向。结合公式 (2.33) - (2.35)，我们得到以下公式：
$$
\alpha=\frac{\mathbf{n}\cdot\mathbf{n}_a}{||\mathbf{n}||^2}
$$

$$
\beta=\frac{\mathbf{n}\cdot\mathbf{n}_b}{||\mathbf{n}||^2}
$$

$$
\gamma=\frac{\mathbf{n}\cdot\mathbf{n}_c}{||\mathbf{n}||^2}
$$

其中 $\mathbf{n}$ 是使用顶点 $a、b和c$ 计算的方程（2.34）；$\mathbf{n}_a$ 是使用顶点 $b、c和p$ 计算的方程（2.34），以此类推。
$$
\mathrm{n_\textit{a}=(c-b)\times(p-b)}
$$

$$
\mathrm{n_\textit{b}=(a-c)\times(p-c)}
$$

$$
\mathrm{n_\textit{c}=(b-a)\times(p-a)}
$$



## 2.10 离散概率

## 2.11 连续概率

## 2.12 蒙特卡罗积分 ★

第2.5节讨论了如何“读取”积分并将其抽象为一个“integrate()”函数。但是我们该如何实际实现这个函数呢？在图形学中，最常见的方法是使用蒙特卡罗积分。蒙特卡罗积分的代数通常很丑陋和令人生畏。但如果我们看一下这个函数：

```c
float shade = average(f(), hemisphere})
```

我们的直觉会找到正确答案。在半球上随机选取一堆点 `vi` 并评估 `f(vi)`，然后求平均值，例如：

```c
float sum = 0.0;
N = 10000; // or some other big number 
for (int i = 1 to N)
    vec3 v = random_point_on_hemisphere()
    sum = sum + f(v)
Average = sum/N
```

就是这么简单！现在你需要一个函数来在单位半球上随机选取点。最简单的方法是使用“拒绝法”，首先通过反复从单位立方体中均匀地选择三个随机数，以此在单位球内选择点：

```c
do
    X = random_from(-1, 1)
    Y = random_from(-1, 1)
    Z = random_from(-1, 1)
while (x*x + y*y + z*z > 1)
```

如果需要在半球中，则翻转Z轴：

```c
if (Z < 0)
    Z = -Z
```

接着，将该点投影到单位半球上：

```c
v = unit_vector(X, Y, Z)
```

这是处理平均值的一种方法。但对于一般积分呢？回想起：

```c
average(f(), domain) = integrate(f(), domain) / integrate(1, domain)
```

So：

```c
integrate(f(), domain()) = average(f(), domain) * integrate(1, domain)
```

对于半球体而言，`integrate(1,domain)`就是该区域的面积，即2π。

因此**蒙特卡罗积分通常是随机点的平均值乘以一个常数**（区域大小-长度、面积等）。 

### 2.12.1 重要性采样

当我们想要对一个具有高低值差异较大的函数进行随机平均时，集中样本在某些区域并使用权重来纠正不均匀性可能会对我们有利。**概率密度函数（PDF）**为此提供了正确的工具：如果我们知道样本的PDF，则可以直接衡量该区域的“过采样”程度。如果使用非均匀采样，则可以得到如下结果。

```c
integrate = average_of_nonuniform_samples(f()/p(), domain)
```

这个公式的一个好处是它也适用于均匀随机样本。在这种情况下，概率密度函数 `p() = 1/integrate(1, domain)`，因此“域”的“大小”被编码在概率密度函数中。

**对于任何给定的蒙特卡罗重要性采样问题，我们都会遵循一种相当公式化的方法：**

1. 确定函数`f()`和积分域（例如，单位球面上的点或三角形上的点）。
2. 选择一种在该域上生成随机样本`xi`的方法，并确保有一种评估每个样本PDF `p(xi)`的方法。
3. 对许多`xi`平均比率`f(xi)/p(xi)`。这是我们对积分的估计。

一个很棒的事情是，任何`p()`都可以使用，并且您将会收敛到正确的答案（但要注意，在`f()`非零的地方，`p()`必须也非零）。您使用哪个`p()`仅影响估计收敛的速度。因此，我们通常从一个恒定的`p()`开始调试我们的代码。

## 常见问题

- **为什么没有向量除法？**

  事实证明，对于向量来说，并不存在“好的”除法类比。然而，通过详细研究这个问题可以激发出四元数（请参阅本章注释中引用的霍夫曼的书）

  

- **是否有像重心坐标那样干净利落的多边形顶点坐标表示方法适用于三角形以外的多边形呢？**

  不幸的是，并没有。即使是凸四边形也要复杂得多。这就是为什么三角形在图形学中如此常见的几何原语之一。

  

- **3D线段有隐式表达方式吗？**

  并没有。但两个3D平面相交所定义出来的便是一个3D线段，因此一个3D线段可以由两个同时满足条件的隐式方程描述。



- **拟蒙特卡罗采样（QMC）或蓝噪声采样与蒙特卡罗采样有何关系？**

  蒙特卡罗核心思想在于你可以对大量“公正”的样本进行平均以估计真实平均值。其中，“公正”可从统计意义上加以解释。但某些样本集合即使不具备随机性也被证明是“公正”的。其中一种是拟蒙特卡罗，它们具有明显的确定性结构而非随机性，但在形式上是均匀的且不涉及统计意义。这些集合通常可以提高收敛速度而无需完全随机化。实际应用中，大多数技术都使用蒙特卡罗形式主义进行开发，因为其数学更易处理；然后，在代码中插入QMC或蓝噪声点，并以经验方式确认仅需要均匀性即可。\



## 注释

向量分析的历史非常有趣。它在19世纪中期主要由格拉斯曼发明，但后来被忽视和重新发明（克罗，1994）。现在，在几何代数领域，一些研究人员正在基于他的思想开发出基于几何代数的图形学（多兰和拉森比，2003）。对于那些想知道为什么特定的标量和向量积在某种意义上是正确的，并且为什么我们没有一个通用的向量除法的读者，在简洁易懂的《关于向量》（霍夫曼，1975）中可以找到答案。另一个重要的几何工具是四元数，在19世纪中期由哈密顿发明。四元数在许多情况下都很有用，尤其是涉及方位时（汉森，2005）。

## 练习题

1. 集合的基数是它包含的元素数量。在IEEE浮点表示（第1.5节）下，浮点数的基数是多少？
2. 是否可能实现一个将32位整数映射到64位整数并具有明确定义逆函数的函数？所有从32位整数到64位整数的函数都有明确定义的逆吗？
3. 用三个区间的笛卡尔积来指定单位立方体（x、y和z坐标都在0和1之间，包括0和1）。
4. 如果您可以访问自然对数函数ln(x)，请说明如何使用它来实现以b为底的log(b, x)函数。负b值应该怎么处理？假设采用IEEE浮点实现。
5. 解二次方程$2x^2+6x+4=0$。
6. 实现一个接受二次方程$Ax^2+Bx+C=0$系数$A、B和C$，并计算两个解答案的函数。使该函数返回有效（非NaN）解答案数量，并填写返回参数，使较小解答案排在前面。
7. 证明第17页上二次公式两种形式等价（假设精确算术），并说明如何选择每个根所需使用哪种形式，以避免减去近似相等而导致精度损失。

8. 举出反例说明对于三维向量 a、b 和 c，不总是成立$\mathrm{a × (b × c) = (a × b) × c} $。
9. 给定非平行的三维向量 a 和 b，计算一个右手正交基使得 u 平行于 a，v 在由 a 和 b 定义的平面内。
10. 求函数$ f(x, y, z) = x² + y - 3z³ $的梯度是多少？
11. 什么是轴对齐二维椭圆的参数形式？
12. 过三个三维点 (1,0,0)，(0,1,0) 和 (0,0,1) 的平面隐式方程是什么？它的参数方程是什么？这个平面的法向量是什么？
13. 给定四个二维点 $a₀、a₁、b₀ 和 b₁$，请设计一个稳健的过程来确定线段 $a₀a₁和 b₀b₁$是否相交。
14. 设计一个稳健的过程来计算与三个二维非共线点相关联的二维点的重心坐标。
15. 计算入门微积分中各种一元积分，并改变样本数量。当样本数量增加时答案收敛速度有多快?

# 3. 光栅图像

> Raster Images

大多数计算机图形图像都是在某种光栅显示器上呈现给用户的。光栅显示器将图像显示为像素的矩形阵列。一个常见的例子是平板电脑显示屏或电视，它具有小型发光像素的矩形阵列，可以单独设置不同颜色以创建任何所需的图像。通过混合红、绿和蓝三种颜色的不同强度来实现不同颜色。大多数打印机（如激光打印机和喷墨打印机）也是光栅设备。它们基于扫描：没有物理网格，但通过在网格上选择点沉积墨水来顺序地放置图像。

!> Pixel is short for “picture element.”

光栅在图像输入设备中也很常见。数码相机包含一个图像传感器，其中包括一组灵敏的像素，每个像素记录落在其上的光线颜色和强度。桌面扫描仪包含一个线性阵列的像素，该阵列横跨正在扫描的页面，每秒进行多次测量以生成一个像素网格。

!> 打印机中的颜色更加复杂，涉及至少四种颜料的混合。

由于光栅在设备中非常普遍，因此光栅图像是存储和处理图像的最常见方式。 光栅图像只是一个二维数组，用于存储每个像素的像素值 - 通常作为三个数字（红色、绿色和蓝色）存储的颜色。 存储在内存中的光栅图像可以通过使用存储图像中的每个像素来控制显示器上一个像素的颜色来显示。

!> 或许是因为光栅图像如此方便，所以光栅设备普及了。

但我们并不总是想以这种方式显示图像。我们可能想改变图像的大小或方向，纠正颜色，甚至在移动的三维表面上展示贴有图像。即使在电视中，显示器的像素数量也很少与正在显示的图像相同。诸如此类的考虑打破了图像像素和显示器像素之间的直接联系。最好将光栅图形视为要显示的理想图形的设备无关描述，并将显示设备视为逼近该理想图形的一种方式。

除了使用数组来描述图片外，还有其他描述图片的方法。矢量图片通过存储形状（由线条或曲线界定）区域的描述来进行描述，并没有参考任何特定象素网格。本质上，这相当于存储用于显示该图片而非需要用于其展示所需象素点信息指令集合。矢量图片主要优势在于它们具有分辨率无关性，并且可以在非常高分辨率设备上良好地展示出来；对应缺点则是必须先进行光栅化才能够被展示出来。通常情况下，在文本、流程图、机械制造等需要清晰度和精确度重要而又不需要摄影效果和复杂阴影的应用中使用矢量图像。

在本章中，我们讨论光栅图像和显示器的基础知识，特别关注标准显示器的非线性。当我们在后面的章节中讨论计算机图像时，了解图像中数字实际意义与像素值之间如何关联到光强度是很重要的。

!> 或者说：你必须知道图像中那些数字实际上代表什么。当我们在后面的章节讨论计算图像时，像素值与光强度相关的重要性需要牢记在心。

## 3.1 光栅设备

在讨论光栅图像的抽象概念之前，看一下使用这些图像的一些具体设备的基本操作是有益的。几个熟悉的光栅设备可以归类为一个简单层次结构：

**输出**

- 显示器

  * 透射式：液晶显示器（LCD）
  * 发射式：发光二极管（LED）显示器
  



**硬拷贝**

* Binary：喷墨打印机

* 连续色调：染料升华打印机

  

**输入** 

- 2D 数组传感器: 数码相机 
- 1D 数组传感器: 扫描仪

### 3.1.1 显示器

当前的显示器，包括电视、数字影院投影仪以及计算机的显示器和投影仪，几乎普遍采用固定像素阵列。它们可以分为发光显示器和透射式显示器两种类型。前者使用能够直接控制光强度的像素来发出光线；后者则是通过调节每个像素所能透过的光线量来实现图像变化。透射式显示器需要一个照明源才能使其工作：在直接观看的情况下，这通常是位于阵列背面的背光源；而在投影仪中，则需要一盏灯泡将经过阵列后产生反射效果的光线投射到屏幕上。而发光型显示器本身就是自己的照明源。

LED（发光二极管）显示屏就是一种发光型显示屏幕。每个像素由一个或多个LED组成，它们都是半导体设备（基于无机或有机半导体），根据通过它们流动电流大小来控制其亮度（见图3.1）。 

彩色显示器中的像素被分成三个独立控制的子像素，每个子像素都有自己的LED，使用不同材料制成，以发出不同颜色的光（图3.2）。当从远处观察显示器时，眼睛无法分离单个子像素，并且感知到的颜色是红色、绿色和蓝色混合而成。

液晶显示器（LCD）是透射型显示器的一个例子。液晶是一种材料，其分子结构使其能够旋转通过它传递的光线偏振度，并且旋转程度可以通过施加电压来调节。 LCD 像素（图3.3）后面有一层偏振膜，因此它受到极化光照明——让我们假设它是水平极化。

![image-20230519000023501](assets/image-20230519000023501.png)

**图3.1** 发光二极管（LED）显示器的操作。

![image-20230519000035331](assets/image-20230519000035331.png)

**图3.2** 平板显示器像素中的红色、绿色和蓝色子像素。

在像素前面的第二层偏振膜是定向传输只有垂直极化光。如果应用电压被设置为液晶层之间不改变极化，所有的光都会被阻挡，像素处于“关闭”（最小强度）状态。如果电压被设置为液晶旋转90°的极化，则从像素背面进入的所有光线将逃逸到前面，并且该像素完全“开启”-它具有最大强度。中间电压将部分旋转极化，使得前置偏振器部分阻止光线通过，在最小和最大之间产生亮度（图3.4）。与彩色LED显示器一样，彩色LCD在每个像素内具有红色、绿色和蓝色子像素，这些子像素是三个独立的带有红、绿和蓝色滤镜的像素。

任何具有固定像素网格的显示器或图象技术都基本上具有由网格大小决定的固定分辨率。对于显示器和图象来说，“分辨率”仅意味着像元网格尺寸：如果桌面监视器具有1920×1200个象元点，则表示它拥有2304000个按1920列和1200行排列的象元点。

![image-20230519000129725](assets/image-20230519000129725.png)

**图3.3** LCD显示器中一个像素的关闭状态（底部），其中前置偏振片阻挡了所有通过后置偏振片的光线，以及开启状态（顶部），其中液晶单元旋转了光线的极化方向，使其能够穿过前置偏振片。图片由Reinhard、Khan、Akyüz和Johnson（2008）提供。

![image-20230519000146135](assets/image-20230519000146135.png)

**图3.4** 液晶显示器（LCD）的工作原理。

!> 显示器的分辨率有时被称为“本机分辨率”，因为大多数显示器可以通过内置转换处理其他分辨率的图像。

需要使用第10章的方法，将分辨率不同的图像转换为1920×1200大小以填充屏幕。

### 3.1.2 硬拷贝设备

3.1.2 硬拷贝设备
将图像永久地记录在纸张上的过程与在显示器上短暂显示图像有非常不同的限制。在印刷中，颜料被分布在纸张或其他介质上，以便当光线从纸张反射时形成所需的图像。打印机是类似于显示器的栅格设备，但许多打印机只能打印二进制图像——每个网格位置要么沉积颜料，要么不沉积颜料，没有中间量可用。

喷墨打印机（图3.5）是通过扫描形成栅格图像的设备示例。喷墨头包含携带颜料的液体墨水，可以在电子控制下喷出非常小的滴落物。头部移动到纸张上，并且当它经过应该接收油墨的网格位置时发射滴落物；未发射任何油墨区域则保持空白。每次扫描后稍微推进一下纸张，并且然后放置下一个网格行。使用几个打印头进行彩色打印，每个都使用具有不同颜色颜料的油墨喷雾剂，在每个网格位置上可以接收任何不同颜色滴落物的组合。因为所有滴落物都是相同的，所以喷墨打印机打印二进制图像：在每个栅格点上，有一个滴落或没有滴落；没有中间阴影。

喷墨打印机没有物理像素阵列；分辨率取决于水滴大小和每次扫描后纸张前进的距离。许多喷墨打印机在打印头中有多个喷嘴，可以在一次通过中进行几次扫描，但最终确定行间距的是纸张前进而不是喷嘴间距。

热转印过程是连续色调印刷过程的一个例子，这意味着可以在每个像素上沉积不同数量的染料——与喷墨打印机不同（图3.6）。包含彩色染料的供体带被夹在纸张或染料接收器和一个包含线性加热元件阵列（对应图像中每一列像素）的打印头之间。当纸张和带子经过头部时，加热元件会开关以加热需要染料的区域，在这些区域内导致染料从带子扩散到纸张上。该过程针对数种颜色重复进行。由于更高温度会导致传输更多染料，因此可以控制沉积在每个网格位置处各种颜色染料量，从而产生连续范围内的颜色。打印头中加热元件的数量确定了页面横向上的固定分辨率，但沿页面方向上的分辨率取决于加热和冷却速度与纸张速度之间的比率。

![image-20230519000312537](assets/image-20230519000312537.png)

**图3.5** 喷墨打印机的操作。

!> 还有一种连续喷墨打印机，它在围绕旋转滚筒的纸张上以连续螺旋路径进行打印，而不是来回移动打印头。

![image-20230519000335457](assets/image-20230519000335457.png)

**图3.6** 热转印打印机的操作原理。

与显示器不同，打印机的分辨率是以像素密度而非总像素数来描述的。因此，一个热转印打印机，在其打印头上每英寸间隔300个元件，则横向每英寸有300个像素（ppi）。如果选择沿页面相同的分辨率，则可以简单地说该打印机的分辨率为300 ppi。喷墨打印机将点放置在每英寸1200个网格点组成的网格上，被描述为具有1200 dpi 的分辨率。由于喷墨打印机是二进制设备，它需要更细密的网格至少出于两个原因：一方面黑白之间存在着突然变化的棱角交错现象或者所谓锯齿状效应（见第9.3节），另一方面当连续色调图像被输出时，高精度则需要通过使用称作“线描”的变密度点阵模式进行中间颜色模拟。

!> “dpi”这个术语经常被用来表示“每英寸像素数”，但是应该在二进制设备中使用dpi，在连续色调设备中使用ppi。

### 3.1.3 输入设备

光栅图像必须来自某个地方，而任何不是由某种算法计算出的图像都必须由某种光栅输入设备测量得到，最常见的是相机或扫描仪。即使在渲染3D场景图像时，照片也经常用作纹理映射（参见第11章）。光栅输入设备必须为每个像素进行一次光度测量，并且（与输出设备一样）它们通常基于传感器阵列。

数字相机就是一个二维阵列输入设备的例子。相机中的图像传感器是带有灵敏光电元件网格的半导体装置。镜头将要拍摄的场景投影到传感器上，然后每个像素测量落在其上的能量，最终产生一个进入输出图像中的数字（如图3.7所示）。与彩色显示器使用红、绿和蓝亚像素类似，大多数彩色相机通过使用颜色滤波阵列或马赛克来让每个像素只看到红、绿或蓝色光线，在缺失值填补过程中留给图像处理软件完成这项工作称为去马赛克化（如图3.8所示）。

![image-20230519000553388](assets/image-20230519000553388.png)

**图3.7** 数码相机的操作。

![image-20230519000608107](assets/image-20230519000608107.png)

**图3.8 ** 大多数彩色数码相机使用类似于此处所示的Bayer马赛克的彩色滤波阵列。每个像素测量红、绿或蓝光。

其他相机使用三个独立的阵列或者三个独立的层来测量每个像素点的红、绿、蓝值，从而产生一个可用的彩色图像，无需进一步处理。相机的分辨率由阵列中固定数量的像素决定，并且通常使用总像素数进行报价：一个拥有3000列和2000行阵列的相机会产生一个分辨率为3000×2000（即600万像素） 的图像，被称为6百万像素（6MP）相机。需要记住，马赛克传感器不能测量完整彩色图像，因此与具有马赛克传感器但是测量同样数量象素点数目不同并能够进行独立红、绿、蓝颜色值测量记录更多关于图像信息。

!> 买相机的人通常使用`megabytes`表示$10^6$，而不是$2^{20}$

平板扫描仪还会为每个像素网格测量红、绿和蓝色值，但与热转印打印机类似，它使用一个一维阵列在被扫描的页面上进行横向移动，并且每秒进行多次测量（图3.9）。页面上的分辨率由阵列大小确定，而沿着页面的分辨率则取决于测量频率与扫描头移动速度之间的比较。彩色扫描仪具有$3×n_x$数组，其中$n_x$是页面上像素数，三行分别覆盖红、绿和蓝色滤光片。通过适当延迟三种颜色测量时间之间的差异，在每个网格点处可以进行三次独立的颜色测量。与连续调节打印机一样，扫描仪的分辨率以每英寸像素数（ppi）报告。

!> 扫描仪的分辨率有时被称为“光学分辨率”，因为大多数扫描仪可以通过内置转换产生其他分辨率的图像。

有了这些关于我们的图像来自何处以及它们将去哪里的具体信息，现在我们将更抽象地讨论图像，以便在图形算法中使用。

## 3.2 图像、像素和几何
我们知道，光栅图像是一个大的像素数组，每个像素存储有关其网格点处图像颜色的信息。我们已经看到各种输出设备如何处理我们发送给它们的图像以及输入设备如何从物理世界中由光形成的图像中获取它们。但是对于计算机中的计算，我们需要一个方便的抽象，独立于任何设备的具体细节，可以用来推断如何生成或解释存储在图像中的值。

当我们测量或再现图像时，它们采取光能的二维分布形式：显示器上发射的光作为显示面位置的函数；相机图像传感器上落在平面各个位置处的光；纸张表面反射（与吸收相对）的光比例作为其位置函数。因此，在物理世界中，图像是定义在二维区域上的函数——几乎总是矩形。因此，我们可以将一个图像抽象成一个函数。
$$
I(x,y):R\rightarrow V
$$
$R ⊂ ℝ2$ ，是一个矩形区域，$V$ 是可能的像素值集合。最简单的情况是理想化的灰度图像，在这种情况下，矩形中的每个点只有亮度（没有颜色），我们可以说 $V = ℝ+$（非负实数）。理想化的彩色图像在每个像素处具有红、绿和蓝三种颜色值，因此 $V = (ℝ+)3$。我们将在下一节讨论 $V$ 的其他可能性。

!> 有没有非矩形的光栅设备？

光栅图像与连续图像的抽象概念有何关联？具体来看，相机或扫描仪中的像素是对其周围一小区域内图像平均颜色的测量。显示器上的像素由红、绿和蓝三个子像素组成，旨在通过光栅图像中相应的像素值控制该面积内图像的平均颜色。在这两种情况下，像素值都是图像颜色局部平均值，并被称为该图像点采样。换句话说，在一个象元中找到数值x时，它意味着“此网格点附近区域内的图形价值为x”。有关将图片视为函数采样表示进一步探讨，请参阅第10章。

![image-20230519001211630](assets/image-20230519001211630.png)

**图3.10** 四像素×三像素屏幕的坐标。请注意，在某些API中，y轴会指向下方。

一个平凡但重要的问题是像素在二维空间中的位置。**这只是一种约定，但建立一致的约定非常重要！**在本书中，光栅图像由表示像素列（i）和行（j）的对(i, j)索引。如果一个图像有nx列和ny行像素，则左下角像素为(0, 0)，右上角为$(n_{x} – 1, n_{y} – 1$)。我们需要2D实屏幕坐标来指定像素位置。我们将把像素采样点放置在整数坐标处，如图3.10所示的4×3屏幕。

!> 在一些API和许多文件格式中，图像的行是从上到下组织的，因此(0, 0)位于左上角。这是出于历史原因：模拟电视传输中的行从顶部开始。

!> 一些系统会将坐标向上或向下移动半个像素，以便将采样点放置在整数之间的中心位置，但是图像的边缘仍然保持在整数处。

图像的矩形区域宽度为$n_x$，高度为$n_y$，并且居中于此网格上，这意味着其每侧都延伸半个像素超出最后一个采样点。因此，一张$n_x×n_y$的图像的矩形区域是：
$$
R-[-0.5, n_x-0.5]\times[0.5, n_y-0.5]
$$
这些坐标只是约定俗成，但在实现相机和视图变换时记住它们将非常重要。

### 3.2.1 像素值
到目前为止，我们已经用实数描述了像素的值，表示图像中某一点的强度（可能分别对应红、绿和蓝色）。这表明图像应该是浮点数数组，每个像素存储一个或三个32位浮点数（用于灰度或黑白图像或RGB彩色图像）。当需要其精度和取值范围时，有时会使用此格式。但由于图片具有大量的像素，并且存储和传输图片所需的内存和带宽通常很少，因此不建议使用。仅一张1000万像素的照片就会消耗约115 MB 的RAM。

!> 为什么是115 MB而不是120 MB？

对于直接显示的图像，需要较小的范围。虽然原则上可能存在无限制的光强度范围，但任何设备都有明显有限的最大强度，在许多情况下，像素具有有界范围通常足以简单地取为[0,1]。例如，在8位图像中可能出现的值是0、1/255、2/255...、254/255和1。存储浮点数值并允许广泛数值范围的图像通常称为高动态范围（HDR）图像，以区别于使用整数存储且具有固定范围或低动态范围（LDR）图像。请参见第20章，深入探讨了高动态范围图像技术和应用。

!> 255的分母比256尴尬，但能够准确表示0和1很重要。

以下是一些常见的像素格式及其应用：

- 1位灰度图像——适用于不需要中间灰度的文本和其他图像（需要高分辨率）；
- 8位RGB固定范围彩色（每个像素总共24位）——适用于网络和电子邮件应用、消费者照片；
- 8或10位固定范围RGB（每个像素24-30位）——数字接口到计算机显示器；
- 12至14位固定范围RGB（每个像素36-42位）——专业摄影的原始相机图像；
- 16位固定范围RGB（每个像素48位）——专业摄影和打印；是处理固定范围图像的中间格式；
- 16  为半精度浮点数RGB —— HDR 图片；实时渲染的中间格式;
- 32  为浮点数 RGB —— 软件渲染和处理HDR图片通用的中间格式。

减少用于存储每个像素的位数会导致图像中出现两种不同类型的人工引入缺陷或瑕疵。首先，使用固定范围值对图像进行编码会在将本应比最大值更亮的像素设置为最大可表示值时产生剪切或裁剪。例如，阳光明媚的场景照片可能包括比白色表面更亮的反射；当将图像转换为固定范围以显示时，这些反射将被裁剪（即使它们是由相机测量得到）。其次，使用有限精度对图像进行编码会导致量化伪影或带状畸变，在需要将像素值四舍五入到最近可表示值时引入可见强度或颜色跳跃。带状畸变在动画和视频中特别隐蔽，在静止图像中可能不太明显，但在前后移动时非常明显。

### 3.2.2 显示器亮度和伽马值
所有现代显示器都采用数字输入来表示像素的“值”，并将其转换为亮度级别。实际上，当显示器关闭时，它们仍会有一些非零的亮度，因为屏幕反射了一些光线。对于我们的目的而言，我们可以认为这是“黑色”的，并且完全打开时是“白色”的。我们假设像素颜色具有从零到一的数值描述。黑色是零，白色是一，在黑与白之间半途而废的灰色是0.5。请注意，“半途”指的是来自像素物理量方面发出光线数量相等，而不是外观上看起来如此。“强度”的人类感知呈非线性状态，并不在本文讨论范围内；更多信息请参见第19章。

要正确地在监视器上生成图像必须理解两个关键问题。首先，监视器对输入信号呈非线性响应特征。例如：如果您给一个显示器三个像素点分别输入 0、0.5 和 1.0，则所显示出来的强度可能分别为 0、0.25 和 1（关闭、四分之一打开和完全打开）。**作为该非线性特征的近似表征，监视器通常由一个γ（“伽马”）值来描述。**该值是公式中的自由度。
$$
\mathrm{display\thinspace intensity}=\mathrm{(maximum\thinspace intensity)}a^{\gamma}
$$
其中a是输入像素值，介于零和一之间。例如，**如果显示器的伽马值为2.0，并且我们输入a = 0.5，则显示的强度将是最大可能强度的四分之一**，因为$0.5^2 = 0.25$。请注意，a = 0映射到零强度，而a = 1则映射到最大强度，无论$γ$ 的值如何。使用$γ$ 描述显示器的非线性仅是一个近似；在估计设备的γ时不需要太高精确度。评估非线性程度的一个好方法是找出哪个a值给出黑色和白色中间亮度的一半。这个a是
$$
0.5=a^{\gamma}
$$
如果我们能找到$a$，那么通过两边取对数，我们就可以推导出$γ$：
$$
\gamma=\frac{\ln 0.5}{\ln{a}}
$$
我们可以通过一种标准技术来找到这个值，即在一个灰色像素的正方形旁边显示黑白相间的棋盘格图案，并输入a（如图3.11所示），然后要求用户调整a（例如使用滑块）直到两侧的平均亮度匹配。当您从远处观察此图像时（或者如果您近视，则不戴眼镜），当a产生介于黑色和白色之间强度的颜色时，图像的两侧看起来大致相同。这是因为模糊的棋盘格混合了偶数个白色和黑色像素，因此总体效果是介于白色和黑色之间一种均匀颜色。一旦我们知道$γ$，就可以对输入进行伽马校正，以使$a = 0.5$ 的值显示出介于黑与白之间强度的颜色。这是通过以下转换完成：
$$
a'=a^{\frac{1}{\gamma}}
$$
![image-20230519002519551](assets/image-20230519002519551.png)

**图3.11** 从远处观察的交替黑白像素位于黑色和白色之间。可以通过找到一个灰度值，其强度与黑白图案相同来推断显示器的伽马值。

!> 对于具有模拟接口的显示器，沿水平方向难以快速改变亮度的情况下，水平黑白条纹比棋盘格更有效。

当这个公式代入方程中时，我们得到
$$
\mathrm{display\thinspace intensity}=(a')^{\gamma}=(a^{\frac{1}{\gamma}})^{\gamma}\mathrm{(maximum\thinspace intensity)}=a\mathrm{(maximum\thinspace intensity)}
$$
真实显示器的另一个重要特征是它们采用量化输入值。因此，虽然我们可以在浮点范围[0, 1]内操作强度，但监视器的详细输入是固定大小的整数。这个整数最常见的范围是0-255，可以保存在8位存储器中。这意味着a的可能值不是[0, 1]中的任何数字，而是
$$
\mathrm{Possible\thinspace values\thinspace for \thinspace \textit a=\{\frac{0}{255},\frac{1}{255},\frac{2}{255},...,\frac{254}{255},\frac{255}{255}\}}
$$
这意味着可能显示的强度值大约为
$$
\{M(\frac{0}{255})^{\gamma},M(\frac{1}{255})^{\gamma},M(\frac{2}{255})^{\gamma},...,M(\frac{254}{255})^{\gamma},M(\frac{255}{255})^{\gamma}\}
$$
其中M是最大强度。在需要精确控制强度的应用中，我们必须实际测量256种可能的强度，而这些强度在屏幕上不同点上可能会有所不同，特别是对于CRT来说。它们也可能随着观看角度而变化。

## 3.3 颜色

大多数计算机图形图像都是以红绿蓝（RGB）颜色定义的。 RGB颜色是一个简单的空间，允许直接转换为大多数计算机屏幕的控制。在本节中，将从用户角度讨论RGB颜色，并以操作便利性为目标。有关颜色的更全面讨论请参见第18章，但是RGB颜色空间的机制将使我们能够编写大多数图形程序。 RGB颜色空间的基本思想是通过混合三种原始光来显示彩色：一种红光、一种绿光和一种蓝光。这些光照以加法方式混合。
